/**
 * Prometheus Metrics
 *
 * Provides comprehensive metrics collection for:
 * - HTTP request duration and counts
 * - WebSocket connections
 * - Skill executions
 * - Error rates
 * - Resource usage
 */

import client, { Counter, Histogram, Gauge, Registry } from 'prom-client';

// Create custom registry
export const register = new Registry();

// Enable default metrics (CPU, memory, event loop, etc.)
client.collectDefaultMetrics({ register });

/**
 * HTTP Metrics
 */
export const httpRequestDuration = new Histogram({
  name: 'http_request_duration_seconds',
  help: 'Duration of HTTP requests in seconds',
  labelNames: ['method', 'route', 'status_code'],
  buckets: [0.01, 0.05, 0.1, 0.5, 1, 2, 5, 10],
  registers: [register],
});

export const httpRequestTotal = new Counter({
  name: 'http_requests_total',
  help: 'Total number of HTTP requests',
  labelNames: ['method', 'route', 'status_code'],
  registers: [register],
});

export const httpRequestErrors = new Counter({
  name: 'http_request_errors_total',
  help: 'Total number of HTTP request errors',
  labelNames: ['method', 'route', 'error_type'],
  registers: [register],
});

/**
 * WebSocket Metrics
 */
export const websocketConnections = new Gauge({
  name: 'websocket_connections_active',
  help: 'Number of active WebSocket connections',
  labelNames: ['organization_id'],
  registers: [register],
});

export const websocketMessagesTotal = new Counter({
  name: 'websocket_messages_total',
  help: 'Total number of WebSocket messages',
  labelNames: ['direction', 'type'],
  registers: [register],
});

export const websocketConnectionDuration = new Histogram({
  name: 'websocket_connection_duration_seconds',
  help: 'Duration of WebSocket connections in seconds',
  labelNames: ['organization_id'],
  buckets: [60, 300, 600, 1800, 3600, 7200, 14400],
  registers: [register],
});

/**
 * Session Metrics
 */
export const sessionsActive = new Gauge({
  name: 'sessions_active',
  help: 'Number of active sessions',
  labelNames: ['organization_id', 'tier'],
  registers: [register],
});

export const sessionsTotal = new Counter({
  name: 'sessions_total',
  help: 'Total number of sessions created',
  labelNames: ['organization_id', 'tier'],
  registers: [register],
});

export const sessionDuration = new Histogram({
  name: 'session_duration_seconds',
  help: 'Duration of sessions in seconds',
  labelNames: ['organization_id', 'tier'],
  buckets: [60, 300, 600, 1800, 3600, 7200, 14400, 28800],
  registers: [register],
});

/**
 * Skill Execution Metrics
 */
export const skillExecutionsTotal = new Counter({
  name: 'skill_executions_total',
  help: 'Total number of skill executions',
  labelNames: ['skill_name', 'organization_id', 'status'],
  registers: [register],
});

export const skillExecutionDuration = new Histogram({
  name: 'skill_execution_duration_seconds',
  help: 'Duration of skill executions in seconds',
  labelNames: ['skill_name', 'organization_id'],
  buckets: [0.1, 0.5, 1, 2, 5, 10, 30, 60],
  registers: [register],
});

export const skillExecutionErrors = new Counter({
  name: 'skill_execution_errors_total',
  help: 'Total number of skill execution errors',
  labelNames: ['skill_name', 'organization_id', 'error_type'],
  registers: [register],
});

/**
 * Channel Metrics
 */
export const channelMessagesTotal = new Counter({
  name: 'channel_messages_total',
  help: 'Total number of channel messages',
  labelNames: ['channel_type', 'direction', 'organization_id'],
  registers: [register],
});

export const channelErrors = new Counter({
  name: 'channel_errors_total',
  help: 'Total number of channel errors',
  labelNames: ['channel_type', 'organization_id', 'error_type'],
  registers: [register],
});

/**
 * Rate Limiting Metrics
 */
export const rateLimitHits = new Counter({
  name: 'rate_limit_hits_total',
  help: 'Total number of rate limit hits',
  labelNames: ['organization_id', 'tier', 'limit_type'],
  registers: [register],
});

export const rateLimitRemaining = new Gauge({
  name: 'rate_limit_remaining',
  help: 'Remaining rate limit quota',
  labelNames: ['organization_id', 'tier', 'limit_type'],
  registers: [register],
});

/**
 * Quota Metrics
 */
export const quotaUsage = new Gauge({
  name: 'quota_usage',
  help: 'Current quota usage',
  labelNames: ['organization_id', 'tier', 'quota_type'],
  registers: [register],
});

export const quotaLimit = new Gauge({
  name: 'quota_limit',
  help: 'Quota limit',
  labelNames: ['organization_id', 'tier', 'quota_type'],
  registers: [register],
});

export const quotaExceeded = new Counter({
  name: 'quota_exceeded_total',
  help: 'Total number of quota exceeded events',
  labelNames: ['organization_id', 'tier', 'quota_type'],
  registers: [register],
});

/**
 * Database Metrics
 */
export const databaseQueryDuration = new Histogram({
  name: 'database_query_duration_seconds',
  help: 'Duration of database queries in seconds',
  labelNames: ['operation', 'table'],
  buckets: [0.001, 0.005, 0.01, 0.05, 0.1, 0.5, 1, 5],
  registers: [register],
});

export const databaseConnectionsActive = new Gauge({
  name: 'database_connections_active',
  help: 'Number of active database connections',
  labelNames: ['pool'],
  registers: [register],
});

export const databaseErrors = new Counter({
  name: 'database_errors_total',
  help: 'Total number of database errors',
  labelNames: ['operation', 'error_type'],
  registers: [register],
});

/**
 * Redis Metrics
 */
export const redisCommandDuration = new Histogram({
  name: 'redis_command_duration_seconds',
  help: 'Duration of Redis commands in seconds',
  labelNames: ['command'],
  buckets: [0.001, 0.005, 0.01, 0.05, 0.1, 0.5, 1],
  registers: [register],
});

export const redisErrors = new Counter({
  name: 'redis_errors_total',
  help: 'Total number of Redis errors',
  labelNames: ['command', 'error_type'],
  registers: [register],
});

/**
 * External Service Metrics
 */
export const externalServiceDuration = new Histogram({
  name: 'external_service_duration_seconds',
  help: 'Duration of external service calls in seconds',
  labelNames: ['service', 'operation'],
  buckets: [0.1, 0.5, 1, 2, 5, 10, 30],
  registers: [register],
});

export const externalServiceErrors = new Counter({
  name: 'external_service_errors_total',
  help: 'Total number of external service errors',
  labelNames: ['service', 'operation', 'error_type'],
  registers: [register],
});

/**
 * Business Metrics
 */
export const messageProcessingDuration = new Histogram({
  name: 'message_processing_duration_seconds',
  help: 'Duration of message processing in seconds',
  labelNames: ['organization_id', 'skill_name'],
  buckets: [0.5, 1, 2, 5, 10, 30, 60, 120],
  registers: [register],
});

export const messagesTotal = new Counter({
  name: 'messages_total',
  help: 'Total number of messages processed',
  labelNames: ['organization_id', 'tier', 'direction'],
  registers: [register],
});

/**
 * Utility functions
 */

/**
 * Create a timer to measure duration
 */
export function startTimer(histogram: Histogram<string>): () => void {
  const start = Date.now();
  return () => {
    const duration = (Date.now() - start) / 1000;
    return duration;
  };
}

/**
 * Wrap async function with metrics
 */
export function instrumentAsync<T>(
  histogram: Histogram<string>,
  labels: Record<string, string>,
  fn: () => Promise<T>
): Promise<T> {
  const end = histogram.startTimer(labels);
  return fn().finally(() => end());
}

/**
 * Get all metrics as Prometheus format
 */
export async function getMetrics(): Promise<string> {
  return register.metrics();
}

/**
 * Get metrics as JSON
 */
export async function getMetricsJSON(): Promise<any> {
  return register.getMetricsAsJSON();
}

/**
 * Reset all metrics (useful for testing)
 */
export function resetMetrics(): void {
  register.resetMetrics();
}

export default {
  register,
  getMetrics,
  getMetricsJSON,
  resetMetrics,
};
